Implement model amendment (`effective_amount`), normalization pipeline, rules (verifications), and tests. Do **not** implement the runner yet. Also add concise RDoc comments. Finally, remember to save **this prompt** itself in `cursor_prompts/` as a `.md` file with a timestamped filename (we’re tracking all prompts).

## Goals
1) Add `effective_amount` to the `FundLoad` model.
2) Implement **Normalizers** (stateless, idempotent) and a simple pipeline.
3) Implement **Rules** (strategy classes returning boolean) that consult the **accepted** repository and the **candidate**.
4) Write RSpec coverage for normalizers and rules.
5) Add RDoc/YARD-style comments to public classes and methods.
6) No CLI/runner yet.

---

## Changes & Files

### 1) Model amendment
- **File**: `lib/models/fund_load.rb`
- Add an attribute `effective_amount : Types::Float`
  - Default behavior: if not provided, set `effective_amount` to `amount`.
  - Keep existing attributes:
    - `id : Types::Integer`
    - `customer_id : Types::Integer`
    - `amount : Types::Float`
    - `timestamp : Types::Params::DateTime`
- Update the **builder** to initialize `effective_amount`:
  - **File**: `lib/builders/fund_load_builder.rb`
  - After parsing `amount`, set `effective_amount` to the parsed amount unless caller overrides.

RDoc on the model and builder:
- Document types, assumptions (UTC if tz missing), amount parsing (“$”, commas), and defaulting of `effective_amount`.

### 2) Normalizers
Create a small normalization stack that transforms a **FundLoad** into another **FundLoad** (immutably) with adjusted `effective_amount`.

- **Base interface**
  - **File**: `lib/normalizers/base.rb`
  - `module Normalizers; class Base; def call(load); raise NotImplementedError; end; end; end`
  - RDoc: explain stateless, idempotent contract.

- **MondayAmountNormalizer**
  - **File**: `lib/normalizers/monday_amount_normalizer.rb`
  - Rule: if `load.timestamp.monday?`, return a **new** FundLoad with `effective_amount = load.effective_amount * 2.0`; otherwise return `load` as-is.
  - Must be **idempotent**. If already doubled, do not double again.
    - Strategy: store a hidden tag is not desirable on the model, so use a pure calculation approach:
      - If `timestamp.monday?` AND `effective_amount == amount` → double.
      - Else → leave as-is.
    - Document this decision in RDoc (why no mutation, why idempotent).

### 3) Rules (boolean strategies)
Each rule is a **class** with:
- `initialize(accepted_repo:)`
- `acceptable?(candidate) -> true/false`
  - It must only read from `accepted_repo` and `candidate`.
  - **Important**: We evaluate **against accepted loads only** (assumption: the velocity constraints concern prior accepted transactions, not mere attempts). Add this assumption in RDoc at the top of each rule file.

Place rules under `lib/rules/`.

Implement:

1. **DailyLoadCountRule**
   - Max 3 **accepted** loads per **customer** per **calendar date**.
   - Use `accepted_repo.find_by_date(candidate.timestamp)` then filter by `customer_id`.
   - `count + 1 <= 3`.

2. **DailyAmountLimitRule**
   - Max `$5_000` **per customer per calendar date**, using **effective_amount**.
   - Sum `effective_amount` of accepted loads for that customer on the same date + candidate’s `effective_amount` ≤ 5000.0.

3. **WeeklyAmountLimitRule**
   - Max `$20_000` **per customer per ISO week**, using **effective_amount`.
   - Provide a small helper module for ISO-week membership:
     - **File**: `lib/utils/date_utils.rb`
     - `same_iso_week?(a_time, b_time)` using `strftime('%G-W%V')` (year-week).
   - Sum within same ISO week + candidate’s `effective_amount` ≤ 20000.0.

4. **PrimeIdSanctionRule** (extra credit)
   - If `candidate.id` is prime:
     - Candidate’s **amount** (not effective) must be ≤ 9_999.
     - Across **all clients** for the candidate’s date, only one **prime id** may be accepted. Check accepted_repo for that date globally.
   - If not prime, pass.
   - Implement a small prime check helper (fast deterministic for ints in reasonable range).
     - **File**: `lib/utils/number_utils.rb` with `prime?(n)`.

**Naming**
- `lib/rules/base.rb` with the interface + RDoc (`acceptable?(candidate)`).

### 4) Specs
Add comprehensive test coverage. Keep tests small and table-driven where possible.

- **Normalizers**
  - **File**: `spec/normalizers/monday_amount_normalizer_spec.rb`
    - Non-Monday → `effective_amount == amount`
    - Monday once → doubled
    - Monday idempotence: calling twice does not double again
  - **File**: `spec/normalizers/pipeline_spec.rb`
    - Pipeline with only Monday normalizer behaves identically to single normalizer
    - Idempotence across repeated calls

- **Rules base**
  - **File**: `spec/rules/base_spec.rb`
    - Ensure abstract `acceptable?` remains abstract (raise NotImplementedError in a dummy subclass)

- **DailyLoadCountRule**
  - **File**: `spec/rules/daily_load_count_rule_spec.rb`
    - 0,1,2 prior accepted → pass
    - 3 prior accepted → fail
    - Different customer same day doesn’t affect count

- **DailyAmountLimitRule**
  - **File**: `spec/rules/daily_amount_limit_rule_spec.rb`
    - Sum with effective amounts (verify Monday double from normalized records)
    - Borderline exactly 5000 → pass; 5000.01 → fail

- **WeeklyAmountLimitRule**
  - **File**: `spec/rules/weekly_amount_limit_rule_spec.rb`
    - Same ISO week accumulation
    - Cross-week boundary (Sun→Mon) resets
    - Borderline exactly 20000 → pass; over → fail

- **PrimeIdSanctionRule**
  - **File**: `spec/rules/prime_id_sanction_rule_spec.rb`
    - Non-prime id always OK (subject to other rules)
    - Prime id once per date globally → pass; a second prime same date (any customer) → fail
    - Prime id with amount > 9999 → fail
    - Ensure it checks **candidate.amount** cap, not `effective_amount`

**Test scaffolding helpers**
- Use the **builder** to create records. For accepted history that should reflect normalization (e.g., Mondays), first pass loads through the **pipeline** manually in specs before adding to repo, so historical records have correct `effective_amount`.
- Seed the repository with those built loads via `InMemoryFundLoadRepository#add`.

### 5) RDoc / YARD
- Brief class-level docs for each Normalizer and Rule:
  - Purpose, assumptions, inputs/outputs.
  - `@param accepted_repo [Repositories::FundLoadRepository]` etc.
  - `@param candidate [Models::FundLoad]`
  - `@return [Boolean]`
- In `README.md`, add a small **Architecture** subsection:
  - Model with `effective_amount`
  - Normalization pipeline (e.g., Monday doubling)
  - Rules consult **accepted** repo
  - Assumptions: attempts vs accepted; ISO week; UTC default

### 6) No Runner Yet
- Do not add/modify `bin/run.rb` beyond what we already have. This change is internal domain code + tests only.

---

## Implementation Notes

- **Idempotence** of Monday normalizer without tags:
  - We rely on `effective_amount == amount` check to determine whether doubling has already been applied. This works because the pipeline is used once when admitting a candidate, and historical accepted records are persisted with their effective amount snapshot in tests.

- **Prime check**:
  - Implement a straightforward integer prime test (handle `<=1` false, `2` true, even check, then odd divisors up to sqrt).

- **ISO week**:
  - Use `strftime('%G-W%V')` on `timestamp` to compare week buckets.

- **Lint/tests**:
  - Ensure RuboCop passes.
  - Ensure `bundle exec rspec` is green.

---

## Commands to run (for verification)
```bash
bundle install
bundle exec rubocop
bundle exec rspec
```
