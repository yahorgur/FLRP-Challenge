Implement the end-to-end processing pipeline **inside `bin/run.rb` only** (no new files).

**Goal**
For each line in `input.txt`:
1) Build a record (using the current builder that maps: id -> transaction_id, customer_id, load_amount -> load_amount_cents, time -> Time).
2) Run all normalizers over the built record (mutating or producing a final normalized record).
3) Evaluate all business rules on the final normalized record and determine the `accepted` boolean.
4) Add the final record to the repository.
5) Append a JSON line to `output.txt` in the format:
   `{"id":"<id>","customer_id":"<customer_id>","accepted":<true|false>}`

**Constraints**
- Make all changes ONLY in `bin/run.rb`.
- Reuse existing components:
  - Builder (e.g., `FundLoadBuilder.build(hash)`).
  - Repository (e.g., `InMemoryFundLoadRepository`).
  - Normalizers (e.g., `Normalizers.run(record)` or an equivalent list you already have).
  - Rules engine (e.g., `Rules.evaluate(record, repo)` that returns true/false).
- If a component doesnâ€™t exist yet (e.g., `Normalizers.run` helper), define a minimal in-file adapter in `run.rb` that calls the known normalizers list (but do NOT create new files).
- Respect the renamed fields (`load_amount_cents`, `effective_load_amount_cents`, `time`).

**CLI / Usage**
- `bin/run.rb <input_path> <output_path>`
- Defaults:
  - `input_path`  default: `input.txt`
  - `output_path` default: `output.txt`
- Ensure the script is executable (`chmod +x bin/run.rb`) and has a proper Ruby shebang.

**Implementation sketch (inside `bin/run.rb`)**
- Parse args with safe defaults.
- Initialize repository: `repo = InMemoryFundLoadRepository.new`
- Open output file for write (overwrite).
- Stream input file line-by-line:
  - Skip blank lines.
  - Parse JSON per line to a Hash.
  - Build record via builder.
  - Run normalizers (assign the resulting normalized record).
  - `accepted = Rules.evaluate(record, repo)` (boolean)
  - Add record to repo (`repo.add(record)`).
  - Write JSON line to output with required keys.
- Fail gracefully for malformed lines: log to STDERR and continue (do not abort the run).
- Do not print anything to STDOUT (the results go to `output.txt`).

**Output format**
Exactly one line per input line, e.g.:
{"id":"15887","customer_id":"528","accepted":true}

pgsql
Copy code

**Edge cases**
- Leading/trailing whitespace around lines.
- Currency parsing already handled by the builder; do not re-parse here.
- Time is assumed UTC in builder; `find_by_date` logic elsewhere should use `record.time.utc.to_date`.
- If rules need repo context (e.g., velocity limits), pass `repo` into evaluation.
- If any sanction/normalizer adjusts `effective_load_amount_cents`, ensure rules use that field.

**Example run**
```bash
./bin/run.rb input.txt output.txt
# Produces output.txt with one JSON line per input record
Verification

After implementation:

bundle exec rubocop passes.

bundle exec rspec remains green.

Run against a small sample input.txt and verify output.txt lines are valid JSON.

Remember
Track this prompt in cursor_prompts/ as a separate .md file with a timestamped filename.